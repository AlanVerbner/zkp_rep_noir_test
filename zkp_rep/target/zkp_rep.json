{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":3310896156203692340,"abi":{"parameters":[{"name":"root_pub_key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"profile_pub_key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"sig_from_root","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"sig_from_profile","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"param_witnesses":{"profile_pub_key":[{"start":64,"end":128}],"root_pub_key":[{"start":0,"end":64}],"sig_from_profile":[{"start":192,"end":256}],"sig_from_root":[{"start":128,"end":192}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"zd3RjlzJdaXhd9G1IVSsHRE7jl9lMBjItjwQYEiGJQ8wMPzuQ7XFanmU2aQ+61jnrtisFYxO/nuT+Wfm4r/97B9++Xf/+r//169+/Y+/+e3P/vZ//NvP/uk3f/+L3/3qN7/+8qN/+1nW/uE//vaff/Hr3//4t7/7xb/87md/m+RvfvbLX//Dl6/6/Pvf/Owff/VPv/zZ387973/zJ9+619dv7Y/x47eef/+ff/Pl9L719HPr6dedp++PW08ft56eW0+vW0+ft56+bj391lndt87qvnVW962z2rfOat86q33rrPats9q3zmrfOqt966z2rbPat85q3zqr59ZZPbfO6rl1Vs+ts3pundVz66yeW2f13Dqr59ZZPbfO6nXrrF63zup166xet87qdeusXrfO6nXrrF63zup166xed85qfXzcevq49fTcenrdevq89fR16+n71tP71tPPraffOqvj1lkdt87quHVWx62zOm6d1XHrrI5bZ3XcOqvj1lkdt85qbp3VvJzVL39k/SFSlZ8+fXx5UvqH7x01rz85PzefXzefP28+f918/r75/L75/HPz+de959fHzeffPL918/zWzfNbN89v3Ty/dfP81s3zWzfPb908v/Pm+Z03z++8eX7nzfM7b57fefP8zpvnd948v/Pm+Z03z++6eX7XzfO7bp7fdfP8rpvnd908v+vm+V03z++6eX7XzfO7b57fffP87pvnd988v/vm+d03z+++eX73zfO7b57fffP89s3z2zfPb988v33z/PbN89s3z2/fPL998/z2zfPbN8/vuXl+z83ze26e33Pz/J6b5/fcPL/nvzy/XxD8ev4c9Sfn983nv57fOl/P/8+vvvwQeTmSc4w/RGZ//PSVfvIFm9dvifqLnT5uPT23nl63nj5vPX3devq+9fS+9fRz6+l3zur8+Lj19HHr6bn19Lr19Hnr6evW0/etp/etp59bT791VsetszpundVx66yOW2d13Dqr49ZZHbfO6rh1VsetszpundXcOqu5dVZz66zm1lnNrbOaW2c1t85qbp3V3DqruXVW69ZZrVtntW6d1bp1VuvWWa1bZ7VundW6dVbr1lmtW2d13jqr89ZZnbfO6rx1VuetszpvndV566zOW2d13jqr89ZZXbfO6rp1Vtets7pundXXb2jaH19fRNj5xscxrvP1IuPjj15v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udeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa512nudZp7neZep7nXae51mnud5l6nuNfrTY/Il1fBv8a+fDk/c19bS643TSLfkQvmCnMTcwtzG3ONuYO5y3JvukW+Jzg0GA2WBqcGlwa3BluDR4NKzlByhpIzlJyh5AwlZyg5Q8kZSs5QcoaSEyUnSk6UnCg5UXKi5ETJiZITJSdKTik5peSUklNKTik5peSUklNKTik5peRMJWcqOVPJmUrOVHKmkjOVnKnkTCVnKjlLyVlKzlJylpKzlJyl5CwlZyk5S8lZSs5WcraSs5WcreRsJWcrOVvJ2UrOVnK2ktNKTis5reS0ktNKTis5reS0ktNKTis5R8k5Ss5Rco6Sc5Sco+QcJecoOUfJOUqOquOh7nioPB5qj4fq46H+eKhAHmqQhyrkoQ456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOOeqQow456pCjDjnqkKMOudQhlzrkUodc6pBLHXKpQy51yKUOudQhlzrkUodc6pBLHXKpQy51yKUOudQhlzrkUodc6pBLHXKpQy51yKUOudQhlzrkUodc6pBLHXKpQy51yKUOudQhlzrkUodc6pBLHXKpQy51yKUOudQhlzrkUodc6pBLHXKpQy51yKUOudQhlzrkUodc6pBLHXKpQy51yKUOudQhlzrkUodc6pDrnZjd5zPYHy+DE4Nv3GOnvwY718vg0ODrq/b8+Ayu/TK4NLg12Bo8GHwju779qL6RXd8R3BpsDR4NXm8e1evHR3W9Cr6RXd8RHBqMBkuDb8hZPwZ3vwwuDW4NtgaPBi8LvinX+PYgv6nX+J5gNFganBpcGtwabA0eDV4YHErOUHKGkjOUnKHkDCVnKDlDyRlKzlByouREyYmSEyUnSk6UnCg5UXKi5ETJKSWnlJxSckrJKSWnlJxSckrJKSXnnXr61tPA+U49fTtYGpwaXBp8IxCu9fmoftTLYGvwaPDC4Dv19O3g0OAbcs74/O248jJYGpwaXBrcGmwNHg1eGHz39sVvB4cGlZyt5GwlZys5W8nZSs5WcraS00pOKzmt5LSS00pOKzmt5LSS00pOKzlHyTlKzlFyjpJzlJyj5Bwl5yg5R8k5Ss4F5OyP9fM/v5z6h9Si1KZUU+pQ6pLUn19L/UNqUCqUKkoRGxexcREbF7FxERsXsTE+Piw2LBaLlcWmxZbFtsXaYsdiRskwSoZRMoySYZQMo2QYJcMoGUbJMEqGURKjJEZJjJIYJTFKYpTEKIlREqMkRkkZJWWUlFFSRkkZJWWUlFFSRkkZJWWUTKNkGiXTKJlGyTRKplEyjZJplEyjZBolyyhZRskySpZRsoySZZQso2QZJcsoWUbJNkq2UbKNkm2UbKNkGyXbKNlGyTZKtlHSRkkbJW2UtFHSRkkbJW2UtFHSRkkbJccoOUbJMUqOUWKydZhtHaZbh/nWYcJ1mHEdplyHOddh0nWYdR2mXYd512HidZh5HaZeh7nXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe42515h7jbnXmHuNudeYe4251zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXstc69l7rXMvZa51zL3WuZey9xrmXud5l6nudcp7rWp1qOp1qOp1qOp1qOp1qOp1qOp1qOp1qOp1qOp1qOp1qOp1qOp1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qOt1qO11mOae53mXie41/Hxptnjy+vSX2NfvpyfuXl95gbmgrnC3MTcwtzGXGPuYO6y3Ju2j+8JDg1Gg6XBqcGlwa3B1uDRoJIzlJyh5AwlZyg5Q8kZSs5QcoaSM5ScoeREyYmSEyUnSk6UnCg5UXKi5ETJiZJTSk4pOaXklJJTSk4pOaXklJJTSk4pOVPJmUrOVHKmkjOVnKnkTCVnKjlTyZlKzlJylpKzlJyl5CwlZyk5S8lZSs5ScpaSs5WcreRsJWcrOVvJ2UrOVnK2krOVnK3ktJLTSk4rOa3ktJLTSk4rOa3ktJLTSs5Rco6Sc5Sco+QcJecoOUfJOUrOUXKOkqPqeKg7HiqPh9rjofp4qD8eKpCHGuShCnmoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEOOOuSoQ4465KhDjjrkqEMudcilDrnUIZc65FKHXOqQSx1yqUMudcilDrnUIZc65FKHXOqQSx1yqUMudcilDrnUIZc65FKHXOqQSx1yqUMudcilDrnUIZc65FKHXOqQSx1yqUMudcilDrnUIZc65FKHXOqQSx1yqUMudcilDrnUIZc65FKHXOqQSx1yqUMudcilDrnUIZc65FKHXOqQSx1yqUMudcilDrnUIZc65HonZvf5DPbHy+DE4Bv32Omvwc71Mjg0+PqqPT8+g2u/DC4Nbg22Bg8G38iubz+qb2TXdwS3BluDR4PXm0f1+vFRXa+Cb2TXdwSHBqPB0uAbctaPwd0vg0uDW4OtwaPBy4Jv6i6+PchvCi++JxgNlganBpcGtwZbg0eDFwaHkjOUnKHkDCVnKDlDyRlKzlByhpIzlJwoOVFyouREyYmSEyUnSk6UnCg5UXJKySklp5ScUnJKySklp5ScUnJKyXmnnr71NHC+U0/fDpYGpwaXBt8IhGt9Pqof9TLYGjwavDD4Tj19Ozg0+IacMz5/O668DJYGpwaXBrcGW4NHgxcG37198dvBoUElZys5W8nZSs5WcraSs5WcreS0ktNKTis5reS0ktNKTis5reS0ktNKzlFyjpJzlJyj5Bwl5yg5R8k5Ss5Rco6Sc/3Z5Hz5wf/5xb/86hd/90+//O2XyO9/7l9//fe/+9Vvfv2HH/7u//7zf/zMl+/9fw==","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"46":{"source":"use dep::std;\nuse dep::ecrecover;\nuse dep::std::hash;\n\nfn main(\n    root_pub_key: pub [u8; 64],\n    profile_pub_key: [u8; 64],\n    sig_from_root: pub [u8; 64],\n    sig_from_profile: pub [u8; 64]\n) {\n    let root_pub_key = ecrecover::secp256k1::PubKey::from_unified(root_pub_key);\n    let root_address = root_pub_key.to_eth_address();\n    println(f\"Root address: {root_address}\");\n    \n    let profile_pub_key = ecrecover::secp256k1::PubKey::from_unified(profile_pub_key);\n\n    // Check if root address has been signed by the profile and recover profile address\n    let root_address_bytes: [u8; 20] = root_address.to_be_bytes(20).as_array();\n    let profile_hashed_message: [u8; 32] = std::hash::keccak256(root_address_bytes, 20);\n    println(f\"Root address hash: {profile_hashed_message}\");\n    let recovered_profile_address = profile_pub_key.ecrecover(sig_from_profile, profile_hashed_message);\n    // Check if the recovered signer (Profile) has been signed by the root \n    let profile_address_bytes: [u8; 20] = recovered_profile_address.to_be_bytes(20).as_array();\n    println(f\"Recovered profile address: {profile_address_bytes}\");\n    let root_hashed_message: [u8; 32] = std::hash::keccak256(profile_address_bytes, 20);\n    println(f\"Root hashed message {root_hashed_message}\");\n    let recovered_root_address = root_pub_key.ecrecover(sig_from_root, root_hashed_message);\n    // Check if signer is the proper root address\n    assert(root_address == recovered_root_address);\n}\n\n#[test]\nfn test_main() {\n    let root_pub_key = [\n        153, 146, 91, 18, 65, 96, 6, 138, 8, 136, 69, 98, 26, 102, 212, 1, 130, 38, 86, 0, 98, 71, 31, 189, 5, 240, 165, 77, 42, 109, 177, 64, 212, 97, 239, 46, 123, 113, 62, 170, 85, 39, 7, 46, 42, 196, 203, 89, 75, 2, 93, 71, 98, 143, 172, 64, 76, 60, 209, 197, 254, 211, 173, 219\n    ];\n    let profile_pub_key = [\n        180, 230, 20, 31, 225, 178, 219, 157, 64, 109, 85, 22, 202, 157, 173, 68, 176, 231, 26, 42, 110, 15, 9, 76, 86, 201, 71, 226, 102, 161, 33, 162, 1, 211, 214, 74, 208, 32, 133, 176, 172, 249, 240, 59, 118, 232, 80, 62, 52, 225, 176, 88, 105, 137, 1, 242, 173, 166, 195, 86, 84, 241, 251, 147\n    ];\n    let profile_signature = [\n        108, 220, 41, 182, 246, 228, 35, 240, 189, 194, 208, 43, 38, 76, 26, 198, 19, 139, 61, 107, 169, 63, 57, 54, 114, 114, 213, 66, 143, 195, 178, 10, 61, 184, 151, 91, 219, 191, 105, 174, 195, 60, 86, 240, 80, 158, 28, 68, 35, 237, 104, 28, 140, 190, 81, 78, 177, 16, 249, 173, 17, 158, 36, 62\n    ];\n    let root_signature = [\n        181, 248, 103, 18, 63, 66, 6, 116, 99, 15, 4, 223, 199, 105, 32, 43, 164, 150, 147, 30, 41, 131, 199, 46, 62, 19, 223, 253, 10, 18, 249, 196, 106, 240, 73, 126, 67, 80, 7, 245, 82, 32, 221, 185, 122, 237, 47, 231, 78, 123, 88, 168, 168, 230, 38, 130, 254, 123, 255, 99, 195, 137, 145, 112\n    ];\n    main(\n        root_pub_key,\n        profile_pub_key,\n        root_signature,\n        profile_signature\n    );\n}\n","path":"/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/zkp_rep/src/main.nr"},"48":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/ecrecover-noir/src/secp256k1.nr"},"49":{"source":"use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount as u8) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount as u8) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/noir-array-helpers/src/lib.nr"}},"names":["main"]}