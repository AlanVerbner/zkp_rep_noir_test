{
  "noir_version": "0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde",
  "hash": 16945413176741017911,
  "abi": {
    "parameters": [
      {
        "name": "root_address_bytes",
        "type": {
          "kind": "array",
          "length": 20,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "profile_address_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "profile_pub_key",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "sig_from_profile",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      }
    ],
    "param_witnesses": {
      "profile_address_hash": [{ "start": 20, "end": 52 }],
      "profile_pub_key": [{ "start": 52, "end": 116 }],
      "root_address_bytes": [{ "start": 0, "end": 20 }],
      "sig_from_profile": [{ "start": 116, "end": 180 }]
    },
    "return_type": null,
    "return_witnesses": [],
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "zZ3hbl3FFUbfxb8ROvv79szs4VWqqgoQqkgoQSRUqhDvXifEdiD34JxVTTv/YnLXaPBZe8NdsZ1f775/+e0v//zHq9c/vHl7983ffr378c13L969evP6/qNf76KOD//w7U8vXr//+O27Fz+/u/vGrX919/L193ff5HH89tXdD69+fHn/6/7b37+6R+I6oltIqh6Q3j5Fvvrspb3p40vHEU8vrd9P99LTc+npbenpfenpY+nptfT0ufL0eSw9PZaevnRW59JZnUtndS6d1bl0VufSWZ1LZ3WunFUdx9LTY+npWnq6l56eS09vS0/vS08fS0+vpacvndVYOquxdFZj6azG0lmNpbMaS2c1ls5qLJ3VWDqrsXRWtXRWtXRWtXRWtXRWtXRWtXRWtXRWtXRWtXRWtXRWvXRWvXRWvXRWvXRWvXRWvXRWvXRWvXRWvXRWvXRWc+ms5tJZzaWzmktnNZfOai6d1Vw6q3lzVtvhj0gbx1+fHqPFx9fGmP70/BsvDuXDi+/f9nx2mVp3mQ/nz//2/Draw/ml/sy/rOrhEx/O+efLtGOny8ROl9FOl/FOl8mdLtN2ukzf6TJjp8vUTpfZaQP3nTZw32kD9502cN9pA/edNnDfaQP3nTZw32kD9502cN9pA4+dNvDYaQOPnTbw2GkDj5028NhpA4+dNvDYaQOPnTbw2GkD104buHbawLXTBq6dNnDttIFrpw1cO23g2mkD104buHbawHOnDTx32sBzpw08d9rAc6cNPHfawHOnDTx32sBzpw08N9rAPjbawD422sA+NtrAPjbawD422sA+NtrAPjbawD422sA+NtrAPnbawLHTBo6dNnDstIFjpw0c/9sN7DoeXpyffeWSo+10mdsbeDx8k3fP/PQyH5Cbe7LXwxeZDc2/vv+sxy+8Oj65kXTz+rM/Xt9/ePGHu9RGd5n73OX2N2X8n+4SG91FG93FG90lN7pL2+gufaO7bLR3tdHe1UZ71xvtXW+0d73R3vVGe9cb7V1vtHe90d71RnvXG+1db7R3c6O9mxvt3dxo7+ZGezc32ru50d7NjfZubrR3c6O9mxvt3bbR3m0b7d220d5tG+3dttHebRvt3bbR3r39HWkjH5g66rc/JeHb3zdWerhT9c+R+Qwy9Wfk9vdg/TUS1xFdR3wdyetIu47068i4jtR15PrTH9ef/rj+9Mf1pz+uP/1x/emP609/XH/64/rTH9ef/rj+9Ov606/rT7+uP/26/vTr+tOv60+/rj/9uv706/rTr+tPf15++vd/MPp13P5ird4f//N3/8vxBM4nMCgoCpqCScFGwU7BQcGi4IRgUHOCmhPUnKDmBDUnqDlBzQlqTlBzgpojao6oOaLmiJojao6oOaLmiJojao6oOabmmJpjao6pOabmmJpjao6pOabmmJqT1Jyk5iQ1J6k5Sc1Jak5Sc5Kak9ScpOY0ak6j5jRqTqPmNGpOo+Y0ak6j5jRqTqPmdGpOp+Z0ak6n5nRqTqfmdGpOp+Z0ak6n5gxqzqDmDGrOoOYMas6g5gxqzqDmDGrOoOYUNaeoOUXNKWpOUXOKmlPUnKLmFDWnqDmTmjOpOZOaM6k5k5ozqTmTmjOpOZOaM6E5og1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGf/CUhffjhm5vvf9lvgqZgUrBRsFNwULAoOCF40pC/AAwKUnMaNadRcxo1p1FzGjWnUXMaNadTczo1p1NzOjWnU3M6NadTczo1p1NzOjVnUHMGNWdQcwY1Z1BzBjVnUHMGNWdQcwY1p6g5Rc0pak5Rc4qaU9ScouYUNaeoOUXNmdScSc2Z1JxJzZnUnEnNmdScSc2Z1JwJzTn5oZFfAgYFRUFTMCnYKNgpOChYFKTmBDUnqDlBzQlqTlBzgpoT1Jyg5gQ1J6g5ouaImiNqjqg5ouaImiNqjqg5ouaImmNqjqk5puaYmmNqjqk5puaYmmNqjqk5Sc1Jag5tyKYN2bQhmzZk04Zs2pBNG7JpQzZtyKYN2bQhmzZk04Zs2pBNG7JpQzZtyKYN2bQhmzZk04Zs2pBNG7JpQzZtyKYN2bQhmzZk04Zs2pBNG7JpQzZtyKYN2bQhmzZk04Zs2pBNG7JpQzZtyD4Ls/14BLtuggOCJ5m0jkfwDz9A5hMwKCgKmoJJwUbBTsFBwaLgZGCeVbLnlMuzSvY8GBQUBU3Bk01e+QjO4ybYKNgpOChYFJwQPKtkw49gxU0wKCgKmoJJwUbBTsFBwaLghKCpOabmmJpjao6pOabmmJpjao6pOabmJDUnqTlJzUlqTlJzkpqT1Jyk5iQ1J6k5jZrTqDmNmtOoOY2a06g5jZrTqDmNmtOoOZ2a06k5nZrTqTknlazi8T1y6TbYKNgpOChYFDx5UxbxBN5833FSyb4ADAqKgqZgUhC+nc/RKTgoWBSkb+froGBQUBQ0BZOC1Jyi5hQ1p6g5Rc2hCTFpQkyaEJMmxKQJMWlCTJoQkybEpAkxaUJsx0HBoKAoaAomBRsFOwUHBYE5yvn17c2hng//86g//IWmT1xATpAz5BJyDXIdcgNyBbnJuJMfEf0lYFBQFDQFk4KNgp2Cg4JFQWpOUHOCmhPUnKDmBDUnqDlBzQlqTlBzgpojao6oOaLmiJojao6oOaLmiJojao6oOabmmJpjao6pOabmmJpjao6pOabmmJqT1Jyk5iQ1J6k5Sc1Jak5Sc5Kak9ScpOY0ak6j5jRqTqPmNGpOo+Y0ak6j5jRqTqPmdGpOp+Z0ak6n5nRqTqfmdGpOp+Z0ak6n5gxqzqDmDGrOoOYMas6g5gxqzqDmDGrOoOYUNaeoOUXNKWpOUXOKmlPUnKLmFDWnqDk0HQdtx0HjcdB6HDQfB+3HQQNy0IIcNCEHbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGLNqQRRuyaEMWbciiDVm0IYs2ZNGGbNqQTRuyaUM2bcimDdm0IZs2ZNOGbNqQTRuyaUM2bcimDdm0IZs2ZNOGbNqQTRuyaUM2bcimDdm0IZs2ZNOGbNqQTRuyaUM2bcimDdm0IZs2ZNOGbNqQTRuyaUM2bcimDdm0IZs2ZNOGbNqQTRuyaUM2bcimDdm0IZs2ZNOGbNqQTRuyaUM2bcimDdm0IZs2ZNOGbNqQTRuyaUM2bcg+C7O9HsFx3AQTgiftcWg8gEPzJhgUvH3Vkccj2PpNsFGwU3BQsCB4Erue/6yexK4vADsFBwWLgvPkszqfPqvtFngSu74ADAqKgqbgiTntCezjJtgo2Ck4KFgUnAzM42CDnEdQUBQ0BZOCjYKdgoOCRcEJwaDmBDUnqDlBzQlqTlBzgpoT1Jyg5gQ1R9QcUXNEzRE1R9QcUXNEzRE1R9QcUXNMzTE1x9QcU3NMzTE1x9QcU3NMzTlLT8+9Dcyz9PQ8aAomBRsFTwLCbI+f1cM3wUHBouCE4Fl6eh4MCp6YU/H4OKZugqZgUrBRsFNwULAoOCF49uWLz4NBQWpOp+Z0ak6n5nRqTqfmdGpOp+YMas6g5gxqzqDmDGrOoOYMas6g5gxqzqDmFDWnqDlFzSlqTlFzippT1Jyi5hQ1p6g5E5jj6F/fXqsjHv5gZvjpZ7X6eKQKUZNQt7fps1QgSogyohJRDVEdUciNgdwYyI1CbhRyo5Abhdwo5EYhNwq5UciNQm4UcmMiNyZyYyI3JnJjIjcmcmMiNyZyYyI3JnLj5GdHP48Fw8QwMywZ1hjWGTYYVgxjlgSzJJglwSwJZkkwS4JZEsySYJYEsySYJWKWiFkiZomYJWKWiFkiZomYJWKWiFliZomZJWaWmFliZomZJWaWmFliZomZJcksSWZJMkuSWZLMkmSWJLMkmSV53ZI2yNu891RDVEfUQBT7bExCgbd576lAlBBlRCE3JnJjIjcmcmMiNyZyg7zN+4AFw8QwMywZ1hjWGTYYVgxjlgSzJJglwSwJZkkwS4JZEsySYJYEsySYJWKWiFkiZomYJWKWiFkiZomYJWKWiFliZomZJWaWmFliZomZJWaWmFliZomZJcksSWZJMkuSWZLMkmSWJLMkmSXsbd7JX+DzLNaYJY1Z0pgljVnSmCWNWdKYJY1Z0pgljVnSmSWdWdKZJZ1Z0pklnVnSmSWdWdKZJZ1ZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWVLMkmKWFLOkmCUstgarrcFya7DeGiy4BiuuwZJrsOYaLLoGq67Bsmuw7hosvAYrr8HSa7D2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69i7VWsvYq1V7H2KtZexdqrWHsVa69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2atZezdqrWXs1a69m7dWsvZq1V7P2mqy9JmuvebW93n/wrxc/v3rx7Y8v394D73/vl9ffvXv15vXHD9/9+6fff+f+tf8B",
  "file_map": {
    "22": {
      "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n",
      "path": "std/field.nr"
    },
    "30": {
      "source": "mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n",
      "path": "std/lib.nr"
    },
    "46": {
      "source": "use dep::std;\nuse dep::ecrecover;\nuse dep::std::hash;\nuse ecrecover::secp256k1::PubKey;\n\ntype SignatureBytes = [u8; 64];\ntype PubKeyArray = [u8; 64];\n\nfn main(\n    root_address_bytes: pub [u8; 20],\n    profile_address_hash: pub [u8; 32],\n    profile_pub_key: PubKeyArray,\n    sig_from_profile: SignatureBytes\n) {\n    let profile_hashed_message: [u8; 32] = std::hash::keccak256(root_address_bytes, 20);\n    let profile_pub_key = PubKey::from_unified(profile_pub_key);\n    let recovered_profile_address = profile_pub_key.ecrecover(sig_from_profile, profile_hashed_message);\n    println(f\"Recovered profile address is {recovered_profile_address}\");\n    let profile_address_bytes: [u8; 20] = recovered_profile_address.to_be_bytes(20).as_array();\n    println(f\"Recovered profile address: {profile_address_bytes}\");\n    assert(std::hash::keccak256(profile_address_bytes, 20) == profile_address_hash);\n}\n\n#[test]\nfn test_main() {\n    let root_address_bytes = [132, 52, 228, 162, 131, 205, 220, 150, 37, 184, 231, 8, 8, 86, 54, 85, 60, 140, 228, 129];\n    let profile_address_hash = [\n        236, 107, 62, 218, 77, 169, 7, 124, 82, 243, 85, 245, 215, 170, 43, 18, 78, 120, 98, 107, 112, 89, 241, 117, 33, 30, 158, 119, 9, 133, 71, 202\n    ];\n    let profile_pub_key = [\n        180, 230, 20, 31, 225, 178, 219, 157, 64, 109, 85, 22, 202, 157, 173, 68, 176, 231, 26, 42, 110, 15, 9, 76, 86, 201, 71, 226, 102, 161, 33, 162, 1, 211, 214, 74, 208, 32, 133, 176, 172, 249, 240, 59, 118, 232, 80, 62, 52, 225, 176, 88, 105, 137, 1, 242, 173, 166, 195, 86, 84, 241, 251, 147\n    ];\n    let profile_signature = [\n        108, 220, 41, 182, 246, 228, 35, 240, 189, 194, 208, 43, 38, 76, 26, 198, 19, 139, 61, 107, 169, 63, 57, 54, 114, 114, 213, 66, 143, 195, 178, 10, 61, 184, 151, 91, 219, 191, 105, 174, 195, 60, 86, 240, 80, 158, 28, 68, 35, 237, 104, 28, 140, 190, 81, 78, 177, 16, 249, 173, 17, 158, 36, 62\n    ];\n    main(\n        root_address_bytes,\n        profile_address_hash,\n        profile_pub_key,\n        profile_signature\n    );\n}\n",
      "path": "/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/zkp_rep/src/main.nr"
    },
    "48": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/ecrecover-noir/src/secp256k1.nr"
    },
    "49": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount as u8) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount as u8) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/noir-array-helpers/src/lib.nr"
    }
  },
  "names": ["main"]
}
