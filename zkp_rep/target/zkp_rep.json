{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":12559892241295560585,"abi":{"parameters":[{"name":"root_pub_key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"sig_from_root","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"profile_pub_key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"profile_address_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"sig_from_profile","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"param_witnesses":{"profile_address_hash":[{"start":192,"end":224}],"profile_pub_key":[{"start":128,"end":192}],"root_pub_key":[{"start":0,"end":64}],"sig_from_profile":[{"start":224,"end":288}],"sig_from_root":[{"start":64,"end":128}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"zd3vjiRIdabxe5nPCGWcE/8Ot7JarbCNV0hosAxeaYW4dzfTVDV4Mrt6fp4w8a2GqTcqOvs5h8knM9/603f/8pt/+o//+39++/2//v4P3/3qf/3pu9/9/p9//cff/v77T//0p+9i7x/+xz/826+//8s//+GPv/73P373q1zxi+9+8/2/fPerHvvPv/juX3/7u998+nr++Rc/+tY53r51PdqXb91//t+/+HR6nTy9HkdPb0dPj6On59HT+9HTx9HT59HT19HTj85qnZzVfDyOnt6Onh5HT8+jp/ejp4+jp8+jp6+jp++jpx+d1XZ0VtvRWW1HZ7UdndV2dFbb0VltR2e1HZ3VdnRW29FZjaOzGkdnNY7Oahyd1Tg6q3F0VuPorMbRWY2jsxpHZzWPzmoendU8Oqt5dFbz6Kzm0VnNo7OaR2c1j85qHp3VfnRW+9FZ7UdntR+d1X50VvvRWe1HZ7UfndV+dFb70VkdR2d1HJ3VcXRWx9NZ7SPfTt/x9dNb7Lfj26e/xR+d3w+fPw6fPw+fvw6fvw+fX2fPn4/D57fD58fh8w/P7zw8v/Pw/M7D8zsPz+88PL/z8Pyuw/O7Ds/vOjy/6/D8rsPzuw7P7zo8v+vw/K7D87sOz+8+PL/78Pzuw/O7D8/vPjy/+/D87sPzuw/P7z48v/vw/Nbh+a3D81uH57cOz28dnt86PL91eH7r8PzW4fmts/PbH4/D57fD58fh8/Pw+f3w+ePw+fPw+evw+fvw+Yfntx2e33Z4ftvh+W2H57cdnt92eH7b4flth+e3/bfn99NT0LfzP9Hyo/Pr7PnP3z014u38MdrXz6/d3o5//M3xEU/vUvP9Lvl33/zDXdpFd4mL7pIX3aVfdJdx0V3mRXdZF91lX3SXuucuedHezYv2bl60d/OivZsX7d28aO/mRXs3L9q7edHezYv2br9o7/aL9m6/aO/2i/Zuv2jv9ov2br9o7/aL9m6/aO/2i/buuGjvjov27rho746L9u64aO+Oi/buuGjvjov27rho746L9u7z9xfPx/prZv79XX6ItJ8eebrF5niP1PpR5OmyWfH2h1kzv/4gfe1t//3523p/ttPH0dPn0dPX0dP30dPr5OnP38r7s53ejp4eR08/Oqvr6Kyuo7O6js7qOjqr6+isrqOzuo/O6j46q/vorO6js7qPzuo+Oqv76Kzuo7O6j87qPjqrdXRW6+is1tFZraOzWkdntY7Oah2d1To6q3V0VuvkrI7H4+jp7ejpcfT0PHp6P3r6OHr6PHr6Onr6Pnr60VltR2e1HZ3VdnRW29FZbUdntR2d1XZ0VtvRWW1HZ7UdndU4OqtxdFbj6KzG0VmNo7MaR2c1js5qHJ3V52/73I+31zX2/KDUp63x/hrIqvzb8598c4v+9s3xo/e4j+fv+/x5LvOX85+/l/OnnL8f4+38HfODP+xXP5Awnr+Z8x91mbjpMnnTZfpNlxk3XWbedJl102X2TZepiy7Tb9rA/aYN3G/awP2mDdxv2sD9pg3cb9rA/aYN3G/awP2mDTxu2sDjpg08btrA46YNPG7awOOmDTxu2sDjpg08btrA46YNPG/awPOmDTxv2sDzpg08b9rA86YNPG/awPOmDTxv2sDzpg28btrA66YNvG7awOumDbxu2sDrpg28btrA66YNvG7awOumDbxv2sD7pg28b9rA+6YNvG/awPumDbxv2sD7pg28b9rA+6YNXDdt4LppA9dNG7hu2sB10wau/9kN/NV2zvH8YxB7vb3bqfrftX/+EHm6J2u/f0j8Eevrf4Cf79Pn4/lHIf5Rl6l7LjOff9DiH3WZdtNl4qbL5E2X6TddZtx0mXnTZS7awPNx0Qaej5s2cLtpA7ebNnC7aQO3mzZwu2kDt5s2cLtpA7ebNnC7aQO3mzZw3LSB46YNHDdt4LhpA8dNGzhu2sBx0waOmzZw3LSB46YNnDdt4LxpA+dNGzhv2sB50wbOmzZw3rSBn39yrT36+ydl22P++e/l8Xz+CbPW+n4P1fhR6OlGa7HWu2bPx38NPf/EVsv57s57fPAB5J/xI8Lz+We2fq7r/PAT4r//E36+lznm849i/eOu0++6zrjrOvOu66y7rrPvuk5ddZ3xuOs67a7r3LWVx11bedy1lcddW3nctZXHXVt53LWVx11bed61leddW3netZXnXVt53rWV511bed61leddW3netZXnXVt53bWV111bed21ldddW3ndtZXXXVt53bWV111bed21ldddW3nftZX3XVt537WV911bed+1lfddW3nftZX3XVt537WV911bue7aynXXVq67tnLdtZXrrq1cd23lumsr111bue7aynXVVl6Pq7byely1ldfjqq28Hldt5fW4aiuvx1VbeT2u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GuZew9xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvaa51zT3muZe09xrmntNc69p7jXNvXZzr93caxf3WlTrUVTrUVTrUVTrUVTrUVTrUVTrUVTrUVTrUVTrUVTrUVTrUVTrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbrUVbr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","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"46":{"source":"use dep::std;\nuse dep::ecrecover;\nuse dep::std::hash;\nuse ecrecover::secp256k1::PubKey;\n\ntype SignatureBytes = [u8; 64];\ntype PubKeyArray = [u8; 64];\n\nfn main(\n    root_pub_key: pub PubKeyArray,\n    sig_from_root: pub SignatureBytes,\n    profile_pub_key: PubKeyArray,\n    profile_address_hash: pub [u8; 32],\n    sig_from_profile: SignatureBytes\n) {\n    let root_pub_key = ecrecover::secp256k1::PubKey::from_unified(root_pub_key);\n    let root_address = root_pub_key.to_eth_address();\n    let root_address_bytes: [u8; 20] = root_address.to_be_bytes(20).as_array();\n    let profile_hashed_message: [u8; 32] = std::hash::keccak256(root_address_bytes, 20);\n    println(f\"Root address: {root_address}\");\n\n    let profile_pub_key = PubKey::from_unified(profile_pub_key);\n    let recovered_profile_address = profile_pub_key.ecrecover(sig_from_profile, profile_hashed_message);\n    println(f\"Recovered profile address is {recovered_profile_address}\");\n    let profile_address_bytes: [u8; 20] = recovered_profile_address.to_be_bytes(20).as_array();\n    println(f\"Recovered profile address: {profile_address_bytes}\");\n    let root_hashed_message: [u8; 32] = std::hash::keccak256(profile_address_bytes, 20);\n    // Check if the recovered signer (Profile) has been signed by the root \n    println(f\"Root hashed message {root_hashed_message}\");\n    let recovered_root_address = root_pub_key.ecrecover(sig_from_root, root_hashed_message);\n    // Check if signer is the proper root address\n    assert(root_pub_key.to_eth_address() == recovered_root_address);\n    assert(std::hash::keccak256(profile_address_bytes, 20) == profile_address_hash);\n}\n\n#[test]\nfn test_main() {\n    let root_pub_key = [\n        153, 146, 91, 18, 65, 96, 6, 138, 8, 136, 69, 98, 26, 102, 212, 1, 130, 38, 86, 0, 98, 71, 31, 189, 5, 240, 165, 77, 42, 109, 177, 64, 212, 97, 239, 46, 123, 113, 62, 170, 85, 39, 7, 46, 42, 196, 203, 89, 75, 2, 93, 71, 98, 143, 172, 64, 76, 60, 209, 197, 254, 211, 173, 219\n    ];\n    let profile_pub_key = [\n        180, 230, 20, 31, 225, 178, 219, 157, 64, 109, 85, 22, 202, 157, 173, 68, 176, 231, 26, 42, 110, 15, 9, 76, 86, 201, 71, 226, 102, 161, 33, 162, 1, 211, 214, 74, 208, 32, 133, 176, 172, 249, 240, 59, 118, 232, 80, 62, 52, 225, 176, 88, 105, 137, 1, 242, 173, 166, 195, 86, 84, 241, 251, 147\n    ];\n    let profile_signature = [\n        108, 220, 41, 182, 246, 228, 35, 240, 189, 194, 208, 43, 38, 76, 26, 198, 19, 139, 61, 107, 169, 63, 57, 54, 114, 114, 213, 66, 143, 195, 178, 10, 61, 184, 151, 91, 219, 191, 105, 174, 195, 60, 86, 240, 80, 158, 28, 68, 35, 237, 104, 28, 140, 190, 81, 78, 177, 16, 249, 173, 17, 158, 36, 62\n    ];\n    let profile_address_hash = [236,107,62,218,77,169,7,124,82,243,85,245,215,170,43,18,78,120,98,107,112,89,241,117,33,30,158,119,9,133,71,202];\n    let root_signature = [\n        181, 248, 103, 18, 63, 66, 6, 116, 99, 15, 4, 223, 199, 105, 32, 43, 164, 150, 147, 30, 41, 131, 199, 46, 62, 19, 223, 253, 10, 18, 249, 196, 106, 240, 73, 126, 67, 80, 7, 245, 82, 32, 221, 185, 122, 237, 47, 231, 78, 123, 88, 168, 168, 230, 38, 130, 254, 123, 255, 99, 195, 137, 145, 112\n    ];\n    main(\n        root_pub_key,\n        root_signature,\n        profile_pub_key,\n        profile_address_hash,\n        profile_signature\n    );\n}\n","path":"/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/zkp_rep/src/main.nr"},"48":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/ecrecover-noir/src/secp256k1.nr"},"49":{"source":"use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u8);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount as u8) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount as u8) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/alan.verbner/Projects/globant/zkp_rep_noir_test/noir-array-helpers/src/lib.nr"}},"names":["main"]}